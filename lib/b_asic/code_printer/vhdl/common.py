"""
Generation of common VHDL constructs.
"""

import re
from datetime import datetime
from subprocess import PIPE, Popen
from typing import Any, Literal, TextIO

# VHDL code generation tab length
VHDL_TAB = r"    "


def write(
    f: TextIO,
    indent_level: int,
    text: str,
    *,
    end: str = "\n",
    start: str | None = None,
) -> None:
    r"""
    Write text to a VHDL file.

    First, ``f'{VHDL_TAB*indent_level}'`` is written to *f* as indentation.
    Immediately after the indentation, *text* is written to *f*. Finally,
    *text* is also written to *f*.

    Parameters
    ----------
    f : TextIO
        The file object to emit VHDL code to.
    indent_level : int
        Indentation level to use. Exactly ``f'{VHDL_TAB*indent_level}'`` is written
        before the text is written.
    text : str
        The text to write to.
    end : str, default: '\n'
        Text to write exactly after *text* is written to *f*.
    start : str, optional
        Text to write before both indentation and *text*.
    """
    if start is not None:
        f.write(start)
    f.write(f"{VHDL_TAB * indent_level}{text}{end}")


def write_lines(f: TextIO, lines: list[tuple[int, str] | tuple[int, str, str]]) -> None:
    """
    Write provided lines to a VHDL file.

    Each tuple ``(int, str, [int])`` in the list *lines* is written to the
    TextIO object *f* using the :func:`vhdl.write` function.

    Parameters
    ----------
    f : TextIO
        The file object to emit VHDL code to.
    lines : list of tuple (int,str) [1], or list of tuple (int,str,str) [2]
        [1]: The first ``int`` of the tuple is used as indentation level for the line
             and the second ``str`` of the tuple is the content of the line.
        [2]: Same as [1], but the third ``str`` of the tuple is passed to parameter
             *end* when calling :func:`vhdl.write`.
    """
    for tpl in lines:
        if len(tpl) == 2:
            write(f, indent_level=tpl[0], text=str(tpl[1]))
        elif len(tpl) == 3:
            write(f, indent_level=tpl[0], text=str(tpl[1]), end=str(tpl[2]))
        else:
            raise ValueError("All tuples in list `lines` must have length 2 or 3")


def b_asic_preamble(f: TextIO) -> None:
    """
    Write a standard BASIC VHDL preamble comment.

    Parameters
    ----------
    f : TextIO
        The file object to write the header to.
    """
    # Try to acquire the current git commit hash
    git_commit_id = None
    try:
        process = Popen(["git", "rev-parse", "--short", "HEAD"], stdout=PIPE)
        git_commit_id = process.communicate()[0].decode("utf-8").strip()
    except:  # noqa: E722
        pass
    write_lines(
        f,
        [
            (0, "--"),
            (0, "-- This code was automatically generated by the B-ASIC toolbox."),
            (0, f"-- Code generation timestamp: ({datetime.now()})"),
        ],
    )
    if git_commit_id:
        write(f, 0, f"-- B-ASIC short commit hash: {git_commit_id}")
    write_lines(
        f,
        [
            (0, "-- URL: https://gitlab.liu.se/da/B-ASIC"),
            (0, "--", "\n\n"),
        ],
    )


def ieee_header(
    f: TextIO,
    std_logic_1164: bool = True,
    numeric_std: bool = True,
    fixed_pkg: bool = False,
) -> None:
    """
    Write the standard IEEE VHDL use header.

    This includes std_logic_1164 and numeric_std.

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the IEEE header to.
    std_logic_1164 : bool, default: True
        Include the std_logic_1164 header.
    numeric_std : bool, default: True
        Include the numeric_std header.
    fixed_pkg : bool, default: False
        Include the fixed_pkg header.
    """
    write(f, 0, "library ieee;")
    if std_logic_1164:
        write(f, 0, "use ieee.std_logic_1164.all;")
    if numeric_std:
        write(f, 0, "use ieee.numeric_std.all;")
    if fixed_pkg:
        write(f, 0, "use ieee.fixed_pkg.all;")
    write(f, 0, "")


def package_header(f: TextIO, package_name: str) -> None:
    write(f, 0, f"use work.{package_name}.all;", end="\n\n")


def signal_declaration(
    f: TextIO,
    name: str,
    signal_type: str,
    default_value: str | None = None,
    indent: int = 1,
    name_pad: int | None = None,
    vivado_ram_style: (
        Literal["block", "distributed", "registers", "ultra", "mixed", "auto"] | None
    ) = None,
    quartus_ram_style: (
        Literal["M4K", "M9K", "M10K", "M20K", "M144K", "MLAB", "logic"] | None
    ) = None,
) -> None:
    """
    Create a VHDL signal declaration.

    The declaration looks like::

        signal {name} : {type} [:= {default_value}];

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the IEEE header to.
    name : str
        Signal name.
    signal_type : str
        Signal type.
    indent : int, optional
        Indentation level to use for this process.
    default_value : str, optional
        An optional default value to the signal.
    name_pad : int, optional
        An optional left padding value applied to the name.
    vivado_ram_style : str, optional
        An optional Xilinx Vivado RAM style attribute to apply to this signal
        declaration. If set, exactly one of: "block", "distributed", "registers",
        "ultra", "mixed" or "auto".
    quartus_ram_style : str, optional
        An optional Quartus Prime RAM style attribute to apply to this signal
        declaration. If set, exactly one of: "M4K", "M9K", "M10K", "M20K", "M144K",
        "MLAB" or "logic".
    """
    # Spacing of VHDL signals declaration always with a single tab
    name_pad = name_pad or 0
    write(f, indent, f"signal {name:<{name_pad}} : {signal_type}", end="")
    if default_value is not None:
        write(f, 0, f" := {default_value}", end="")
    write(f, 0, ";")
    if vivado_ram_style is not None:
        write_lines(
            f,
            [
                (indent, "attribute ram_style : string;"),
                (
                    indent,
                    f'attribute ram_style of {name} : signal is "{vivado_ram_style}";',
                ),
            ],
        )
    if quartus_ram_style is not None:
        write_lines(
            f,
            [
                (indent, "attribute ramstyle : string;"),
                (
                    indent,
                    f'attribute ramstyle of {name} : signal is "{quartus_ram_style}";',
                ),
            ],
        )


def alias_declaration(
    f: TextIO,
    name: str,
    signal_type: str,
    value: str | None = None,
    name_pad: int | None = None,
) -> None:
    name_pad = name_pad or 0
    write(f, 1, f"alias {name:<{name_pad}} : {signal_type} is {value};")


def constant_declaration(
    f: TextIO,
    name: str,
    signal_type: str,
    value: Any,
    name_pad: int | None = None,
) -> None:
    """
    Write a VHDL constant declaration with a name, a type and a value.

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the constant declaration to.
    name : str
        Signal name.
    signal_type : str
        Signal type.
    value : anything convertible to str
        Default value to the signal.
    name_pad : int, optional
        An optional left padding value applied to the name.
    """
    name_pad = 0 if name_pad is None else name_pad
    write(f, 1, f"constant {name:<{name_pad}} : {signal_type} := {value!s};")


def type_declaration(
    f: TextIO,
    name: str,
    alias: str,
) -> None:
    """
    Write a VHDL type declaration with a name tied to an alias.

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the type declaration to.
    name : str
        Type name alias.
    alias : str
        The type to tie the new name to.
    """
    write(f, 1, f"type {name} is {alias};")


def entity_declaration(
    f: TextIO,
    entity_name: str,
    generics: list[str] | None = None,
    ports: list[str] | None = None,
    indent: int = 0,
) -> None:
    write(f, indent, f"entity {entity_name} is")
    if generics:
        write(f, indent + 1, "generic (")
        for i, generic in enumerate(generics):
            write(f, indent + 2, f"{generic}{'' if i == len(generics) - 1 else ';'}")
        write(f, indent + 1, ");")
    if ports:
        write(f, indent + 1, "port (")
        for i, port in enumerate(ports):
            write(f, indent + 2, f"{port}{'' if i == len(ports) - 1 else ';'}")
        write(f, indent + 1, ");")
    write(f, indent, f"end entity {entity_name};", end="\n\n")


def component_declaration(
    f: TextIO,
    entity_name: str,
    generics: list[str] | None = None,
    ports: list[str] | None = None,
    indent: int = 1,
) -> None:
    write(f, indent, f"component {entity_name}")
    if generics:
        write(f, indent + 1, "generic (")
        for i, generic in enumerate(generics):
            write(f, indent + 2, f"{generic}{'' if i == len(generics) - 1 else ';'}")
        write(f, indent + 1, ");")
    if ports:
        write(f, indent + 1, "port (")
        for i, port in enumerate(ports):
            write(f, indent + 2, f"{port}{'' if i == len(ports) - 1 else ';'}")
        write(f, indent + 1, ");")
    write(f, indent, "end component;")


def component_instantiation(
    f: TextIO,
    label: str,
    entity_name: str,
    generic_mappings: list[str] | None = None,
    port_mappings: list[str] | None = None,
    indent: int = 1,
) -> None:
    write(f, indent, f"{label}: {entity_name}")
    if generic_mappings:
        write(f, indent + 1, "generic map (")
        for i, generic_mapping in enumerate(generic_mappings):
            write(
                f,
                indent + 2,
                f"{generic_mapping}{'' if i == len(generic_mappings) - 1 else ','}",
            )
        write(f, indent + 1, ")")
    if port_mappings:
        write(f, indent + 1, "port map (")
        for i, port_mapping in enumerate(port_mappings):
            write(
                f,
                indent + 2,
                f"{port_mapping}{'' if i == len(port_mappings) - 1 else ','}",
            )
        write(f, indent + 1, ");")


def process_prologue(
    f: TextIO,
    sensitivity_list: str,
    indent: int = 1,
    name: str | None = None,
) -> None:
    """
    Write the prologue of a regular VHDL process with a user provided sensitivity list.

    This method should almost always be followed by a :func:`process_epilogue`.

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the type declaration to.
    sensitivity_list : str
        Content of the process sensitivity list.
    indent : int, default: 1
        Indentation level to use for this process.
    name : str, optional
        An optional name for the process.
    """
    if name is not None:
        write(f, indent, f"{name}: process({sensitivity_list})")
    else:
        write(f, indent, f"process({sensitivity_list})")
    write(f, indent, "begin")


def process_epilogue(
    f: TextIO,
    sensitivity_list: str | None = None,
    indent: int = 1,
    name: str | None = None,
) -> None:
    """
    Write the epilogue of a regular VHDL process.

    Parameters
    ----------
    f : TextIO
        The TextIO object to write the type declaration to.
    sensitivity_list : str, optional
        Content of the process sensitivity list. Not needed when writing the epilogue.
    indent : int, default: 1
        Indentation level to use for this process.
    indent : int, default: 1
        Indentation level to use for this process.
    name : str, optional
        An optional name of the ending process.
    """
    _ = sensitivity_list
    write(f, indent, "end process", end="")
    if name is not None:
        write(f, 0, " " + name, end="")
    write(f, 0, ";")


def synchronous_process_prologue(
    f: TextIO,
    clk: str = "clk",
    indent: int = 1,
    name: str | None = None,
) -> None:
    """
    Write the prologue of a regular VHDL synchronous process with a single clock object.

    The clock is the only item in the sensitivity list and is triggering a rising edge
    block by some body of VHDL code.

    This method is almost always followed by a :func:`synchronous_process_epilogue`.

    Parameters
    ----------
    f : TextIO
        The TextIO to write the VHDL code onto.
    clk : str
        Name of the clock.
    indent : int, default: 1
        Indentation level to use for this process.
    name : str, optional
        An optional name for the process.
    """
    process_prologue(f, sensitivity_list=clk, indent=indent, name=name)
    write(f, indent + 1, "if rising_edge(clk) then")


def synchronous_process_epilogue(
    f: TextIO,
    clk: str | None = None,
    indent: int = 1,
    name: str | None = None,
) -> None:
    """
    Write the epilogue of a regular VHDL synchronous process with a single clock.

    The clock is the only item in the sensitivity list and is triggering a rising edge
    block by some body of VHDL code.

    Parameters
    ----------
    f : TextIO
        The TextIO to write the VHDL code onto.
    clk : str, optional
        Name of the clock.
    indent : int, default: 1
        Indentation level to use for this process.
    name : str, optional
        An optional name for the process.
    """
    _ = clk
    write(f, indent + 1, "end if;")
    process_epilogue(f, sensitivity_list=clk, indent=indent, name=name)


def synchronous_process(
    f: TextIO,
    clk: str,
    body: str,
    indent: int = 1,
    name: str | None = None,
) -> None:
    """
    Write a regular VHDL synchronous process with a single clock.

    The clock is the only item in the sensitivity list and is triggering a rising edge
    block by some body of VHDL code.

    Parameters
    ----------
    f : TextIO
        The TextIO to write the VHDL code onto.
    clk : str
        Name of the clock.
    body : str
        Body of the `if rising_edge(clk) then` block.
    indent : int, default: 1
        Indentation level to use for this process.
    name : str, optional
        An optional name for the process.
    """
    synchronous_process_prologue(f, clk, indent, name)
    for line in body.split("\n"):
        if len(line):
            write(f, indent + 2, f"{line}")
    synchronous_process_epilogue(f, clk, indent, name)


def synchronous_memory(
    f: TextIO,
    clk: str,
    read_ports: set[tuple[str, str, str]],
    write_ports: set[tuple[str, str, str]],
    name: str | None = None,
) -> None:
    """
    Infer a VHDL synchronous reads and writes.

    Parameters
    ----------
    f : TextIO
        The TextIO to write the VHDL code onto.
    clk : str
        Name of clock identifier to the synchronous memory.
    read_ports : Set[Tuple[str,str]]
        A set of strings used as identifiers for the read ports of the memory.
    write_ports : Set[Tuple[str,str,str]]
        A set of strings used as identifiers for the write ports of the memory.
    name : str, optional
        An optional name for the memory process.
    """
    assert len(read_ports) >= 1
    assert len(write_ports) >= 1
    synchronous_process_prologue(f, clk=clk, name=name)
    for read_name, address, read_enable in read_ports:
        write_lines(
            f,
            [
                (3, f"if {read_enable} = '1' then"),
                (4, f"{read_name} <= memory({address});"),
                (3, "end if;"),
            ],
        )
    for write_name, address, we in write_ports:
        write_lines(
            f,
            [
                (3, f"if {we} = '1' then"),
                (4, f"memory({address}) <= {write_name};"),
                (3, "end if;"),
            ],
        )
    synchronous_process_epilogue(f, clk=clk, name=name)


def asynchronous_read_memory(
    f: TextIO,
    clk: str,
    read_ports: set[tuple[str, str, str]],
    write_ports: set[tuple[str, str, str]],
    name: str | None = None,
) -> None:
    """
    Infer a VHDL memory with synchronous writes and asynchronous reads.

    Parameters
    ----------
    f : TextIO
        The TextIO to write the VHDL code onto.
    clk : str
        Name of clock identifier to the synchronous memory.
    read_ports : Set[Tuple[str,str]]
        A set of strings used as identifiers for the read ports of the memory.
    write_ports : Set[Tuple[str,str,str]]
        A set of strings used as identifiers for the write ports of the memory.
    name : str, optional
        An optional name for the memory process.
    """
    assert len(read_ports) >= 1
    assert len(write_ports) >= 1
    synchronous_process_prologue(f, clk=clk, name=name)
    for write_name, address, we in write_ports:
        write_lines(
            f,
            [
                (3, f"if {we} = '1' then"),
                (4, f"memory(to_integer({address})) <= {write_name};"),
                (3, "end if;"),
            ],
        )
    synchronous_process_epilogue(f, clk=clk, name=name)
    for read_name, address, _ in read_ports:
        write(f, 1, f"{read_name} <= memory(to_integer({address}));")


def is_valid_vhdl_identifier(identifier: str) -> bool:
    """
    Test if identifier is a valid VHDL identifier, as specified by VHDL 2019.

    An identifier is a valid VHDL identifier if it is not a VHDL reserved keyword and
    it is a valid basic identifier as specified by IEEE STD 1076-2019 (VHDL standard).

    Parameters
    ----------
    identifier : str
        The identifier to test.

    Returns
    -------
    Returns True if identifier is a valid VHDL identifier, False otherwise.
    """
    # IEEE STD 1076-2019:
    # Sec. 15.4.2, Basic identifiers:
    # * A basic identifier consists only of letters, digits, and underlines.
    # * A basic identifier is not a reserved VHDL keyword
    is_basic_identifier = (
        re.fullmatch(pattern=r"[a-zA-Z][0-9a-zA-Z_]*", string=identifier) is not None
    )
    return is_basic_identifier and not is_vhdl_reserved_keyword(identifier)


def is_vhdl_reserved_keyword(identifier: str) -> bool:
    """
    Test if identifier is a reserved VHDL keyword.

    Parameters
    ----------
    identifier : str
        The identifier to test.

    Returns
    -------
    Returns True if identifier is reserved, False otherwise.
    """
    # List of reserved keyword in IEEE STD 1076-2019.
    # Sec. 15.10, Reserved words:
    reserved_keywords = (
        "abs",
        "access",
        "after",
        "alias",
        "all",
        "and",
        "architecture",
        "array",
        "assert",
        "assume",
        "attribute",
        "begin",
        "block",
        "body",
        "buffer",
        "bus",
        "case",
        "component",
        "configuration",
        "constant",
        "context",
        "cover",
        "default",
        "disconnect",
        "downto",
        "else",
        "elsif",
        "end",
        "entity",
        "exit",
        "fairness",
        "file",
        "for",
        "force",
        "function",
        "generate",
        "generic",
        "group",
        "guarded",
        "if",
        "impure",
        "in",
        "inertial",
        "inout",
        "is",
        "label",
        "library",
        "linkage",
        "literal",
        "loop",
        "map",
        "mod",
        "nand",
        "new",
        "next",
        "nor",
        "not",
        "null",
        "of",
        "on",
        "open",
        "or",
        "others",
        "out",
        "package",
        "parameter",
        "port",
        "postponed",
        "procedure",
        "process",
        "property",
        "protected",
        "private",
        "pure",
        "range",
        "record",
        "register",
        "reject",
        "release",
        "rem",
        "report",
        "restrict",
        "return",
        "rol",
        "ror",
        "select",
        "sequence",
        "severity",
        "signal",
        "shared",
        "sla",
        "sll",
        "sra",
        "srl",
        "strong",
        "subtype",
        "then",
        "to",
        "transport",
        "type",
        "unaffected",
        "units",
        "until",
        "use",
        "variable",
        "view",
        "vpkg",
        "vmode",
        "vprop",
        "vunit",
        "wait",
        "when",
        "while",
        "with",
        "xnor",
        "xor",
    )
    return identifier.lower() in reserved_keywords
