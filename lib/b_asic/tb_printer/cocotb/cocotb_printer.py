"""Module for generating cocotb test benches."""

from collections import defaultdict
from pathlib import Path

from apytypes import APyCFixed, APyCFloat

from b_asic.special_operations import Input, Output


class CocotbPrinter:
    def __init__(self, sim_results=None, sequence_map=None):
        if sim_results is not None and isinstance(
            next(iter(sim_results.values())), (complex, APyCFixed, APyCFloat)
        ):
            raise NotImplementedError(
                "CocotbPrinter does not support complex values yet."
            )
        self.sim_results = sim_results
        self.sequence_map = sequence_map

    def print(
        self, arch, path, waves: bool = False, gui: bool = False, csv: bool = False
    ) -> None:
        path = Path(path)

        template_path = Path(__file__).parent / "template.py"
        with Path.open(template_path) as template_file:
            template = template_file.read()

        # Fill the sequence map from simulation results if not provided
        if self.sequence_map is None and self.sim_results is not None:
            seq_map = defaultdict(dict)

            is_complex = any(
                isinstance(v[0], (complex, APyCFixed, APyCFloat))
                for v in self.sim_results.values()
            )

            # Track which graph_ids have been marked as input/output and their schedule
            io_marked = {}  # {gid: {'is_input': bool, 'pe_name': str, 'start_time': int}}

            # First, scan architecture to mark which gids are inputs vs outputs
            for pe in arch.processing_elements:
                if pe.operation_type not in (Input, Output):
                    continue
                for pe_process in pe.collection:
                    gid = pe_process.operation.graph_id
                    io_marked[gid] = {
                        "is_input": pe.operation_type is Input,
                        "pe_name": pe.entity_name,
                        "start_time": pe_process.start_time,
                    }

            # Track which (gid, sample_idx) pairs have been processed
            processed = set()

            # Now populate sequence map
            for gid in io_marked:
                values = self.sim_results[gid]

                for sample_idx in range(len(values)):
                    value = values[sample_idx]
                    pe_name = io_marked[gid]["pe_name"]
                    is_input = io_marked[gid]["is_input"]
                    start_time = io_marked[gid]["start_time"]
                    schedule_time = arch.schedule_time

                    # Calculate actual hardware cycle time
                    time = start_time + sample_idx * schedule_time

                    if is_complex:
                        if is_input:
                            seq_map[time][f"{pe_name}_0_in_re"] = value.to_bits()[0]
                            seq_map[time][f"{pe_name}_0_in_im"] = value.to_bits()[1]
                        else:
                            seq_map[time][f"{pe_name}_0_out_re"] = value.to_bits()[0]
                            seq_map[time][f"{pe_name}_0_out_im"] = value.to_bits()[1]
                    else:
                        if is_input:
                            seq_map[time][f"{pe_name}_in"] = value.to_bits()[0]
                        else:
                            seq_map[time][f"{pe_name}_out"] = value.to_bits()[0]

                    processed.add((gid, sample_idx))

            self.sequence_map = dict(seq_map)

        # Replace the file docstring
        tb_content = template.replace(
            '"""Template for cocotb testbench."""',
            '"""cocotb testbench generated by B-ASIC."""',
        )

        # Replace placeholders in the template with actual values
        tb_content = tb_content.replace(
            "SEQUENCE = {}",
            f"SEQUENCE = {self.sequence_map}",
        )
        tb_content = tb_content.replace(
            'ENTITY_NAME = ""', f'ENTITY_NAME = "{arch.entity_name}"'
        )
        tb_content = tb_content.replace("WAVES = False", f"WAVES = {waves!s}")
        tb_content = tb_content.replace("GUI = False", f"GUI = {gui!s}")
        tb_content = tb_content.replace("CSV = False", f"CSV = {csv!s}")

        with Path.open(path / "tb.py", "w") as output_file:
            output_file.write(tb_content)

        with Path.open(path / "Makefile", "w") as makefile:
            makefile.write("SIM ?= ghdl\n")
            makefile.write("TOPLEVEL_LANG ?= vhdl\n\n")
            makefile.write("PWD := $(shell pwd)\n\n")
            makefile.write(
                "VHDL_SOURCES := $(shell find \"$(PWD)\" -type f \\( -name '*.vhd' -o -name '*.vhdl' \\) 2>/dev/null)\n\n"
            )
            makefile.write("COCOTB_TOPLEVEL ?= r3\n")
            makefile.write("COCOTB_TEST_MODULES ?= tb\n\n")
            makefile.write("include $(shell cocotb-config --makefiles)/Makefile.sim\n")
